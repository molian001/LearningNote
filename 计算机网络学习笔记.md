#计算机网络
##（一）数据链路层
###七层模型和协议

网络被分为七层，由底层向高层依次是：物理层，数据链路层，网络层，传输层，会话层，表示层和应用层。

###物理层：

物理层处于 OSI 七层模型的最底端，它的主要任务是将比特流与电子信号进行转换。

在计算机的世界中，一切都由 0 和 1 组成。你看到的这篇文章，在通过网络传输到你电脑的过程中，自然也是以 0 和 1 的形式存在。但是网络传输的介质(比如光纤，双绞线，电波等)中显然是不存在 0 和 1 的。比如在光线中，数据通过光的形式传递。0 和 1 以光的亮灭表示，其中的转换由物理层完成。

如果没有物理层，由 0 和 1 构成的比特流就无法在物理介质中传播。

###数据链路层：

数据链路层处于 OSI 七层模型的第二层，它定义了通过通信介质相互连接的设备之间，数据传输的规范。

在数据链路层中，数据不再以 0、1 序列的形式存在，它们被分割为一个一个的“帧”，然后再进行传输。

数据链路层中有两个重要的概念：MAC 地址和分组交换。

###MAC地址：

MAC 地址是被烧录到网卡 ROM 中的一串数字，长度为 48 比特，它在世界范围内唯一(不考虑虚拟机自定义 MAC 地址)。由于 MAC 地址的唯一性，它可以被用来区分不同的节点，一旦指定了 MAC 地址，就不可能出现不知道往哪个设备传输数据的情况。

###分组交换：

分组交换是指将较大的数据分割为若干个较小的数据，然后依次发送。使用分组交换的原因是不同的数据链路有各自的最大传输单元(MTU: Maximum Transmission Unit)。不同的数据链路就好比不同的运输渠道。     

以以太网(一种数据链路)为例，它的MTU是 1500 字节，也就是通过以太网传输的数据，必须分割为若干帧，每个帧的数据长度不超过 1500 字节。如果上层传来的数据超过这个长度，数据链路层需要分割后再发送。

###以太网帧：

我们用以太网举例，介绍一下以太网帧的格式。

以太网帧的开头是“前导码(Preamble)”，长度为 8 字节，这一段没什么用，重点在于以太网帧的本体。

本体由首部，数据和 FCS 三部分组成：

![](http://upload-images.jianshu.io/upload_images/1171077-e7e4556d9828aa09.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

类型部分存储了上层协议的编号，比如上层是 IP 协议，则编号为 0800。

FCS 表示帧校验序列(Frame Check Sequence)，用于判断帧是否在传输过程中有损坏(比如电子噪声干扰)。FCS 保存着发送帧除以某个多项式的余数，接收到的帧也做相同计算，如果得到的值与 FCS 相同则表示没有出错。

###交换机：

交换机是一种在数据链路层工作的网络设备，它有多个端口，可以连接不同的设备。交换机根据每个帧中的目标 MAC 地址决定向哪个端口发送数据，此时它需要参考“转发表”

转发表并非手动设置，而是交换机自动学习得到的。当某个设备向交换机发送帧时，交换机将帧的源 MAC 地址和接口对应起来，作为一条记录添加到转发表中。

下图描述了交换机自学过程的原理

![](http://upload-images.jianshu.io/upload_images/1171077-751c6b2d18995ed9.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

关于数据链路层，最重要的一点还是它的定义：“通过通信介质相互连接的设备之间，数据传输的规范”。这说明数据链路层的协议适用于处于同一种数据链路两端的节点。如果不能理解这一点，就无法理解网络层和 IP 协议。

数据链路层的意义在于，如果没有数据链路层，数据只能以流的形式存在与通信介质中，不知道该发送往哪里，过长的数据流可能无法在通信介质中传输。


##IP协议

IP协议处于OSI参考模型的第三层——网络层，网络层的主要作用是实现终端节点间的通信。IP协议是网络层的一个重要协议，网络层中还有ARP(获取MAC地址)和ICMP协议(数据发送异常通知)

数据链路层的作用在于实现同一种数据链路下的包传递，而网络层则可以实现跨越不同数据链路的包传递。比如主机A通过Wi-Fi连接到路由器B，路由器B通过以太网连接到路由器C，而路由器C又通过Wi-Fi与主机D保持连接。这时主机A向D发送的数据包就依赖于网络层进行传输。

这篇文章主要介绍IP协议的基本知识和IP首部，IP协议可以分为三大作用模块：IP寻址、路由和IP分包。

###IP地址

IP地址是一种在网络层用于识别通信对端信息的地址。它有别于数据链路层中的MAC地址，后者用于标识同一链路下不同的计算机。

举一个形象的例子，我要从家里去东北大学，通信两端的地址分别是家和学校，他们相当于IP地址。然而没有交通工具可以让我从家直接去学校，所以我先要打车去火车站，然后坐高铁到火车站，再转公交去学校。这三次中转分别属于三种交通方式(数据链路)，每一次中转都有起点和终点，他们就相当于MAC地址。每次中转可以称为一跳(Hop)

IP地址由32位正整数表示，为了直观的表示，我们把它分成4个部分，每个部分由8位整数组成，对应十进制的范围就是0-255。

比如172.20.1.1可以表示为：10101100 00010100 00000001 00000001。转换规则很简单，就是分别把四个部分的十进制(0-255)与8位二进制数字进行转换。

从功能上看，IP地址由两部分组成：网络标识和主机标识。

网络标识用于区分不同的网段，相同段内的主机必须拥有相同的网络表示，不同段内的主机不能拥有相同的网络标识。

主机标识用于区分同一网段下不同的主机，它不能在同一网段内重复出现。

32位IP地址被分为两部分，到底前多少位是网络标识呢？一般有两种方法表示：IP地址分类、子网掩码。

###IP分类：

IP地址分为四个级别，分别为A类、B类、C类和D类。分类的依据是IP地址的前四位：

A类IP地址是第一位为“0”的地址。A类IP地址的前8位是网络标识，用十进制标识的话0.0.0.0-127.0.0.0是A类IP地址的理论范围。另外我们还可以得知，A类IP地址最多只有128个(实际上是126个，下文不赘述)，每个网段内主机上限为2的24次方，也就是16，777，214个。

B类IP地址是前两位为“10“的地址。B类IP地址的前16位是网络标识，用十进制标识的话128.0.0.0-191.255.0.0是B类IP地址的范围。B类IP地址的主机标记长度为16位，因此一个网段内可容纳主机地址上限为65534个。

C类IP地址是前三位为“110”的地址。C类IP地址的前24位是网络标识，用十进制标识的话192.0.0.0-223.255.255.0是C类IP地址的范围。C类地址的后8位是主机标识，共容纳254个主机地址。

D类IP地址是前四位为“1110”的地址。D类IP地址的网络标识长32位，没有主机标识，因此常用于多播。

###子网掩码：

IP地址总长度32位，它能表示的主机数量有限，大约在43亿左右。而IP地址分类更是造成了极大的浪费，A、B类地址一共也就一万多个，而世界上包含主机数量超过254的网段显然不止这么点。

我们知道IP地址分类的本质是区分网络标识和主机标识，另一种更加灵活、细粒度的区分方法是使用子网掩码。

子网掩码长度也是32位，由一段连续的1和一段连续的0组成。1的长度就表示网络标识的长度。以IP地址172.20.100.52为例，它本来是一个B类IP地址(前16位是网络标识)，但通过子网掩码，它可以是前26为为网络标识的IP地址：

![](http://upload-images.jianshu.io/upload_images/1171077-586e7dbc405373ec.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

这样就占用了原IP地址的主机号，扩展了网络标识，如对于一个C类地址，它用21位来标识网络号，要将其划分为2个子网则需要占用1位原来的主机标识位。此时网络号位变为22位为主机标示变为7位。

下表是C类地址子网划分及相关子网掩码：

子网位数 子网掩码 主机数 可用主机数

  1 255.255.255.128 128 126

  2 255.255.255.192 64 62

  3 255.255.255.224 32 30

  4 255.255.255.240 16 14

  5 255.255.255.248 8 6

  6 255.255.255.252 4 2


###路由控制：

路由控制(Routing)是指将分组数据发送到目标地址的功能，这个功能一般由路由器完成。(不要与家里用的小型无线路由器混为一谈)

路由器中保存着路由控制表，它在路由控制表中查找目标IP地址对应的下一个路由器地址。下图描述了这一过程：

![](http://upload-images.jianshu.io/upload_images/1171077-f4f34e8f4809e437.jpg?imageMogr2/auto-orient/strip%7CimageView2/2)

主机A的地址是10.1.1.30,要把数据发往地址为10.1.2.10的主机。在主机A的路由表中，保存了两个字段，由于目标地址10.1.2.10与10.1.1.0/24段不匹配，所以它被发往默认路由10.1.1.1也就是图中路由器1的左侧网卡的IP地址。

路由器1继续在它自己的路由控制表中查找目标地址10.1.2.10，它发现目标地址属于10.1.2.0/24这一段，因此将数据转发至下一个路由器10.1.0.2，也就是路由器2的左侧网卡的地址。

路由器2在自己的路由控制表中查找目标地址10.1.2.10，根据表中记录将数据发往10.1.2.1接口，也就是自己的右侧网卡的IP地址。主机B检查目标IP地址和自己相同，于是接收数据。

###路由控制表

路由控制的关键在于路由控制表，路由控制表可以由管理员手动设置，称为静态路由控制，但是估计大部分人没这么干过。这是因为路由器可以喝其他路由器互换信息比即使自动刷新路由表，这个信息交换的协议并没有在IP协议中定义，而是由一个叫做“路由协议”的协议管理。

###环路

上图中，假设主机A向一个不存在的IP地址发送数据，并且路由器1、2、3设置的默认路由形成了一个循环，那么数据将在网络中不断转发最终导致网络拥堵。这个问题将在下文分析IP首部时得到解决。

###IP报文分割重组

在数据链路层中，我们已经提到过不同的数据链路有不同的最大传输单元(MTU)。因此IP协议的一个任务是对数据进行分片和重组。分片由发送端主机和路由器负责，重组由接收端主机负责。

### 路径MTU发现 ###

分片会加重路由器的负担，因此只要条件允许，我们都不希望路由器对IP数据包进行分片处理。另外，如果一个分片丢失，整个IP数据报都会作废。

解决以上问题的技术是“路径MTU发现”。主机会首先获取整个路径中所有数据链路的最小MTU，并按照整个大小将数据分片。因此传输过程中的任何一个路由器都不用进行分片工作。

为了找到路径MTU，主机首先发送整个数据包，并将IP首部的禁止分片标志设为1.这样路由器在遇到需要分片才能处理的包时不会分片，而是直接丢弃数据并通过ICMP协议将整个不可达的消息发回给主机。

主机将ICMP通知中的MTU设置为当前MTU，根据整个MTU对数据进行分片处理。如此反复下去，直到不再收到ICMP通知，此时的MTU就是路径MTU。

以UDP协议发送数据为例：

![](http://upload-images.jianshu.io/upload_images/1171077-1f00189eee68a92a.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

###重组

接收端根据IP首部中的标志(Flag)和片偏移(Fragment Offset)进行数据重组。具体内容将在分析IP首部时详细解释。

###IP首部(IPv4)

IP首部是一个有些复杂的结构，我们不用记忆它的结构，只需了解每个部分的作用即可，这样可以加深对IP协议的理解。

![](http://upload-images.jianshu.io/upload_images/1171077-51d3b2c4f83a36fe.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

其中几个重要的部分介绍如下：

总长度(Total Length)：表示IP首部与数据部分总的字节数，该段长16比特，所以IP包的最大长度为65535字节(2^16)。虽然不同数据链路的MTU不同，但是IP协议屏蔽了这些区别，通过自己实现的数据分片功能，从上层的角度来看，IP协议总是能够以65535为最大包长进行传输。

- 标识（ID：Identification）：用于分片重组。属于同一个分片的帧的ID相同。但即使ID相同，如果目标地址、源地址、上层协议中有任何一个不同，都被认为不属于同一个分片。

- 标志（Flags）：由于分片重组，由三个比特构成。            
第一个比特未使用，目前必须是0。           
第二个比特表示是否进行分片，0表示可以分片，1表示不能分片。在路径MTU发现技术中就用到了这个位。             
第三个比特表示在分片时，是否表示最后一个包。1表示不是最后一个包，0表示分配中最后一个包。         

- 片偏移（FO: Fragment Offset）：由13比特组成，表示被分片的段相对于原始数据的位置。它可以表示8192(2^13)个位置，单位为8字节，所以最大可以表示8 x 8192 = 65536字节的偏移量。

- 生存时间（TTL: Time To Live）：表示包可以经过多少个路由器的中转。每经过一个路由器，TTL减1。这样可以避免前文提到的无限传递包的问题。

- 协议： 表示IP首部的下一个首部属于哪个协议。比如TCP协议的编号为6，UDP编号为17.

- 首部校验和：用于检查IP首部是否损坏
- 可选项：仅在试验或诊断时用，可以没有。如果有，需要配合填充（Padding）占满32比特。

##（三）IP协议相关技术

在前两篇文章中，我分别介绍了数据链路层和网络层的IP协议。虽然这个系列教程的重点是搞定 TCP/IP，不过不用着急，本文简要介绍完与 IP 协议相关的技术，下一篇文章就会正式、详细的介绍 传输层与 TCP 协议。这篇文章会介绍 DNS、ARP、NAT 协议，这些内容虽然与 TCP 没有直接关联，但理解它们的原理有助于巩固基础知识，更好的理解网络的工作原理。

###DNS 解析

IP地址用于识别通信双方的地址，但它是一串长数字，不方便记忆，人们希望主机有自己自己的名字，这个名字是唯一的，而且容易记住。于是，诞生了“域名”的概念。域名是一种为了识别主机名称和机构名的具有分层的名称，比如在域名 neu.edu.cn中，neu是主机名，edu 和 cn 是不同层次下的机构名。

域名和 IP 地址都可以唯一对应一台主机，DNS 协议的作用就是将自身具有意义的域名转换成不容易记住的 IP 地址。

域名是分层的，每层都有自己的 DNS 服务器用于处理 DNS 解析的请求。这样的好处在于每层的服务器不用关注过多的信息，它只要知道自己这一层下的域名服务器信息即可。以解析域名： www.ietf.org为例：

![DNS解析过程](http://upload-images.jianshu.io/upload_images/1171077-fee307f330da613b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

###ARP协议：

ARP 协议(Address Resolution Protocol)用于通过目标 IP 地址，定位下一个接收数据包的网络设备的 MAC 地址。如果目标主机处在同一个数据链路上，那么可以直接得到目标主机的 MAC 地址，否则会得到下一条路由器的 MAC 地址。

ARP 协议的工作原理可以分为两部分：ARP 请求和 ARP 响应。 首先，源主机会通过广播发送一个 ARP 请求包：“我要与 IP 地址为 xxx 的主机通话，谁知道它的 MAC地址？”。

数据链路上的所有主机都会收到这条消息并检查自己的 IP 地址，如果与 ARP 请求包中的 IP 地址一致，主机就会发送 ARP 响应包：“我就是 IP 地址为 xxx 的主机，我的 MAC 地址是：xxxx”。

下图表示了 ARP 协议的工作机制：

![ARP机制](http://upload-images.jianshu.io/upload_images/1171077-51bfbcfa875295d3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

在实际的使用过程中，每次往目标主机发送数据都要使用 ARP 是很低效的，通常的做法是把获取到的 MAC 地址缓存一段时间。一般来说，一旦源主机向目标地址发送一个数据包，接下来继续发送多次的概率非常大，因此这种缓存非常容易命中。

当下一次发送 ARP 请求或超过一定时间后，缓存都会失效，这保证了即使 MAC 地址与 IP 地址的对应关系发生了变化，数据包依然能够被正确的发往目标地址。

再次强调一下，MAC 和 IP 地址虽然看上去功能类似(都是用于唯一区分主机)，但是两者缺一不可。如果只有 IP 地址，虽然可以跳过 ARP，直接在数据链路上发一个广播，但是这仅适用于通信双方处于同一个数据链路下的情况。如果双方处于不同的数据链路，数据报无法穿透中间的路由器。

如果全世界只用 MAC 地址，那么请参考交换机的自学过程，可以想象这个过程会带来庞大的，不必要的流量。

正因为 MAC 和 IP 地址缺一不可，所以才产生了 ARP 这样的协议将两者关联起来。

###NAT 和 NAPT 技术

NAT (Network Address Translator) 是一种用于将局域网中的私有地址转换成全局 IP 地址的技术。

在连接上无线路由器的时候，如果检查一下设备的 IP 地址，也许你会发现是类似于 192.168.1.1 这样的局域网 IP 地址。那不同网段中，IP 地址都是 192.168.1.1 的主机改如何通信呢？

下图描绘了 NAT 的工作原理：

局域网中 IP 地址为 10.0.0.10 的主机向全局 IP 地址 163.221.120.9 发送数据。NAT 路由器将数据包的源地址修改成自己的全局 IP 地址：202.244.174.37。同理，接收数据时，路由器把目标地址 202.244.174.37 翻译成内网地址：10.0.0.10

![](http://upload-images.jianshu.io/upload_images/1171077-e8540d2e539e72c5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

路由器只有一个对外的全局 IP 地址，如果有多个内网主机都向外部通讯怎么办呢？这时就要使用 NAPT 技术，它和 NAT 从原理上类似，但它可以转换 TCP 和 UDP 端口号。

使用 NAPT 技术时，不同的内网 IP 被转换成同一个公共 IP 地址，也就是路由器对外显示的全局 IP 地址，但是被附加不同的端口号以示区分：

![](http://upload-images.jianshu.io/upload_images/1171077-7f9ad0357a5ba4d4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

不管是 NAT 还是 NAPT，都需要路由内部维护一张自动生成的地址转换表。以 TCP 为例，建立 TCP 连接首次握手的 SYN 包发出时会生成这个表，关闭连接时会发出 FIN 包，收到这个包的应答时转换表被删除。

如果暂时不了解 TCP 协议和三次握手也没有关系，下一篇文章将会有详细的讲解。

##（四）TCP/UDP协议简介

介绍最重要的传输层。传输层位于 OSI 七层模型的第四层（由下往上）。顾名思义，传输层的主要作用是实现应用程序之间的通信。网络层主要是保证不同数据链路下数据的可达性，至于如何传输数据则是由传输层负责。

###传输层协议简介

常见的传输层协议主要有 TCP 协议和 UDP 协议。TCP 协议是面向有连接的协议，也就是说在使用 TCP 协议传输数据之前一定要在发送方和接收方之间建立连接。一般情况下建立连接需要三步，关闭连接需要四步。

建立 TCP 连接后，由于有数据重传、流量控制等功能，TCP 协议能够正确处理丢包问题，保证接收方能够收到数据，与此同时还能够有效利用网络带宽。然而 TCP 协议中定义了很多复杂的规范，因此效率不如 UDP 协议，不适合实时的视频和音频传输。

UDP 协议是面向无连接的协议，它只会把数据传递给接收端，但是不会关注接收端是否真的收到了数据。但是这种特性反而适合多播，实时的视频和音频传输。因为个别数据包的丢失并不会影响视频和音频的整体效果。

IP 协议中的两大关键要素是源 IP 地址和目标 IP 地址。而刚刚我们说过，传输层的主要作用是实现应用程序之间的通信。因此传输层的协议中新增了三个要素：源端口号，目标端口号和协议号。通过这五个信息，可以唯一识别一个通信。

不同的端口用于区分同一台主机上不同的应用程序。假设你打开了两个浏览器，浏览器 A 发出的请求不会被浏览器 B 接收，这就是因为 A 和 B 具有不同的端口。

协议号用于区分使用的是 TCP 还是 UDP。因此相同两台主机上，相同的两个进程之间的通信，在分别使用 TCP 协议和 UDP 协议时也可以被正确的区分开来。

用一句话来概括就是：“源 IP 地址，目标 IP 地址，源端口号，目标端口号和协议号”这五个信息只要有一个不同，都被认为是不同的通信。

###UDP首部

UDP 协议最大的特点就是简单，它的首部如下图所示：
![](http://upload-images.jianshu.io/upload_images/1171077-11cf05a9a126636e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

校验和用来判断数据在传输过程中是否损坏。计算这个校验和的时候，不仅考虑源端口号和目标端口号，还要考虑 IP 首部中的源 IP 地址，目标 IP 地址和协议号（这些又称为 UDP 伪首部）。这是因为以上五个要素用于识别通信时缺一不可，如果校验和只考虑端口号，那么另外三个要素收到破坏时，应用就无法得知。这有可能导致不该收到包的应用收到了包，改收到包的应用反而没有收到。

这个概念同样适用于即将介绍的 TCP 首部。

###TCP首部

和 UDP 首部相比，TCP 首部要复杂得多。解析这个首部的时间也相应的会增加，这是导致 TCP 连接的效率低于 UDP 的原因之一。
![](http://upload-images.jianshu.io/upload_images/1171077-9fcb9006301d9db0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

其中某些关键字段解释如下：

- 序列号：它表示发送数据的位置，假设当前的序列号为 s，发送数据长度为 l，则下次发送数据时的序列号为 s + l。在建立连接时通常由计算机生成一个随机数作为序列号的初始值。

- 确认应答号：它等于下一次应该接收到的数据的序列号。假设发送端的序列号为 s，发送数据的长度为 l，那么接收端返回的确认应答号也是 s + l。发送端接收到这个确认应答后，可以认为这个位置以前所有的数据都已被正常接收。

- 数据偏移：TCP 首部的长度，单位为 4 字节。如果没有可选字段，那么这里的值就是 5。表示 TCP 首部的长度为 20 字节。

- 控制位：改字段长度为 8 比特，分别有 8 个控制标志。依次是 CWR，ECE，URG，ACK，PSH，RST，SYN 和 FIN。在后续的文章中你会陆续接触到其中的某些控制位。

- 窗口大小：用于表示从应答号开始能够接受多少个 8 位字节。如果窗口大小为 0，可以发送窗口探测。

- 紧急指针：尽在 URG 控制位为 1 时有效。表示紧急数据的末尾在 TCP 数据部分中的位置。通常在暂时中断通信时使用（比如输入 Ctrl + C）。

###TCP握手

TCP 是面向有连接的协议，连接在每次通信前被建立，通信结束后被关闭。了解连接建立和关闭的过程通常是考察的重点。连接的建立和关闭过程可以用一张图来表示：

![](http://hi.csdn.net/attachment/201108/7/0_131271823564Rx.gif)

通常情况下，我们认为客户端首先发起连接。

###三次握手建立连接
![](http://img.my.csdn.net/uploads/201210/23/1350985085_3123.jpg)
ACK ： TCP协议规定，只有ACK=1时有效，也规定连接建立后所有发送的报文的ACK必须为1
SYN(SYNchronization) ： 在连接建立时用来同步序号。当SYN=1而ACK=0时，表明这是一个连接请求报文。对方若同意建立连接，则应在响应报文中使SYN=1和ACK=1. 因此,  SYN置1就表示这是一个连接请求或连接接受报文。

FIN （finis）即完，终结的意思， 用来释放一个连接。当 FIN = 1 时，表明此报文段的发送方的数据已经发送完毕，并要求释放连接。

首先由Client发出请求连接即 SYN=1 ACK=0  (请看头字段的介绍), TCP规定SYN=1时不能携带数据，但要消耗一个序号,因此声明自己的序号是 seq=x
然后 Server 进行回复确认，即 SYN=1 ACK=1 seq=y, ack=x+1,
再然后 Client 再进行一次确认，但不用SYN 了，这时即为 ACK=1, seq=x+1, ack=y+1.

这个过程可以用以下三句形象的对话表示：

1. （客户端）：我要建立连接了。
2. （服务端）：我知道你要建立连接了，我这边没有问题。
3. （客户端）：我知道你知道我要建立连接了，接下来我们就正式开始通信。

###为什么是三次握手

根据一般的思路，我们可能会觉得只要两次握手就可以了，第三步确认看似是多余的。那么 TCP 协议为什么还要费力不讨好的加上这一次握手呢？

这是因为在网络请求中，我们应该时刻记住：“网络是不可靠的，数据包是可能丢失的”。假设没有第三次确认，客户端向服务端发送了 SYN，请求建立连接。由于延迟，服务端没有及时收到这个包。于是客户端重新发送一个 SYN 包。回忆一下介绍 TCP 首部时提到的序列号，这两个包的序列号显然是相同的。

假设服务端接收到了第二个 SYN 包，建立了通信，一段时间后通信结束，连接被关闭。这时候最初被发送的 SYN 包刚刚抵达服务端，服务端又会发送一次 ACK 确认。由于两次握手就建立了连接，此时的服务端就会建立一个新的连接，然而客户端觉得自己并没有请求建立连接，所以就不会向服务端发送数据。从而导致服务端建立了一个空的连接，白白浪费资源。

在三次握手的情况下，服务端直到收到客户端的应答后才会建立连接。因此在上述情况下，客户端会接受到一个相同的 ACK 包，这时候它会抛弃这个数据包，不会和服务端进行第三次握手，因此避免了服务端建立空的连接。

###ACK 确认包丢失怎么办

三次握手其实解决了第二步的数据包丢失问题。那么第三步的 ACK 确认丢失后，TCP 协议是如何处理的呢？

按照 TCP 协议处理丢包的一般方法，服务端会重新向客户端发送数据包，直至收到 ACK 确认为止。但实际上这种做法有可能遭到 SYN 泛洪攻击。所谓的泛洪攻击，是指发送方伪造多个 IP 地址，模拟三次握手的过程。当服务器返回 ACK 后，攻击方故意不确认，从而使得服务器不断重发 ACK。由于服务器长时间处于半连接状态，最后消耗过多的 CPU 和内存资源导致死机。

正确处理方法是服务端发送 RST 报文，进入 CLOSE 状态。这个 RST 数据包的 TCP 首部中，控制位中的 RST 位被设置为 1。这表示连接信息全部被初始化，原有的 TCP 通信不能继续进行。客户端如果还想重新建立 TCP 连接，就必须重新开始第一次握手。

###四次握手关闭连接

![](http://img.my.csdn.net/uploads/201210/23/1350990937_5362.jpg)

当客户A 没有东西要发送时就要释放 A 这边的连接，A会发送一个报文（没有数据），其中 FIN 设置为1,  服务器B收到后会给应用程序一个信，这时A那边的连接已经关闭，即A不再发送信息（但仍可接收信息）。  A收到B的确认后进入等待状态，等待B请求释放连接， B数据发送完成后就向A请求连接释放，也是用FIN=1 表示， 并且用 ack = u+1(如图）， A收到后回复一个确认信息，并进入 TIME_WAIT 状态， 等待 2MSL 时间。

这个过程可以用以下四句形象的对话表示：

1. （客户端）：我要关闭连接了。
2. （服务端）：你那边的连接可以关闭了。
3. （服务端）：我这边也要关闭连接了。
4. （客户端）：你那边的连接可以关闭了。
由于连接是双向的，所以双方都要主动关闭自己这一侧的连接。

###关闭连接的最后一个 ACK 丢失怎么办

实际上，在第三步中，客户端收到 FIN 包时，它会设置一个计时器，等待相当长的一段时间。如果客户端返回的 ACK 丢失，那么服务端还会重发 FIN 并重置计时器。假设在计时器失效前服务器重发的 FIN 包没有到达客户端，客户端就会进入 CLOSE 状态，从而导致服务端永远无法收到 ACK 确认，也就无法关闭连接。但是服务器存在一个保活状态，即如果A突然故障死机了，那B那边的连接资源什么时候能释放呢？  就是保活时间到了后，B会发送探测信息， 以决定是否释放连接。

##（五）TCP协议详解

TCP 协议是面向有连接的协议，它具有丢包重发和流量控制的功能，这是它区别于 UDP 协议最大的特点。本文就主要讨论这两个功能。

###数据包重发
###数据发送
丢包重发的前提是发送方能够知道接收方是否成功的接收了消息。所以，在 TCP 协议中，接收端会给发送端返回一个通知，也叫作确认应答（ACK），这表示接收方已经收到了数据包。

根据上一节对 TCP 首部的分析得知，ACK 的值和下次发送数据包的序列号相等。因此 ACK 也可以理解为：“发送方，下次你从这个位置开始发送！”。下图表示了数据发送与确认应答的过程：


![](http://upload-images.jianshu.io/upload_images/1171077-ac16ce758aa65805.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

数据包和 ACK 应答都有可能丢失，在这种情况下，发送方如果在一段时间内没有收到 ACK，就会重发数据：

![](http://upload-images.jianshu.io/upload_images/1171077-ede6985be7bee329.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

即使网络连接正常，由于延迟的存在，接收方也有可能收到重复的数据包，因此接收方通过 TCP 首部中的 SYN 判断这个数据包是否曾经接收过。如果已经接收过，就会丢弃这个包。

###重传超时时间(RTO)

如果发送方等待一段时间后，还是没有收到 ACK 确认，就会启动超时重传。这个等待的时间被称为重传超时时间(RTO，Retransmission TimeOut)。RTO 的值具体是多久呢？

首先，RTO 的值不是固定的，它是一个动态变化的时间。这个时间总是略大于连接往返时间（RTT，Round Trip Time）。这个设定可以这样理解：“数据发送给对方，再返回到我这里，假设需要 10 秒，那我就等待 12秒，如果超过 12 秒，那估计就是回不来了。”

RTT 是动态变化的，因为谁也不知道网络下一时刻是否拥堵。而当前的 RTO 需要根据未来的 RTT 估算得出。RTO 不能估算太大，否则会多等待太多时间；也不能太小，否则会因为网络突然变慢而将不该重传的数据进行重传。

RTO 有自己的估算公式，可以保证即使 RTT 波动较大，它的变化也不会太剧烈。

##TCP 窗口

按照之前的理论，在数据包发出后，直至 ACK 确认返回以前，发送端都无法发送数据，而且包的往返时间越长，网络利用效率和通信性能就越低。前两张图片形象的解释了这一点。

为了解决这个问题，TCP 使用了“窗口”这个概念。窗口具有大小，它表示无需等待确认应答就可以继续发送数据包的最大数量。比如窗口大小为 4 时，数据发送的示意图如下：

![](http://upload-images.jianshu.io/upload_images/1171077-4a3c0615f2dbb2f3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

不等确认就连续发送若干个数据包会不会有问题呢？我们首先来看数据包丢失问题。

我们知道 TCP 首部中的 ACK 字段表示接收方已经收到数据的最后位置。因此，接收方成功接收到了 1-1000 字节的数据后，它会发送一个 ACK = 1001 的确认包。假设 1001-2000 字节的数据包丢失了，由于窗口长度比较大，发送方会继续发送 2001-3000 字节的数据包。接收端并不会返回这个数据包的确认，因为它最后收到的数据还是 1-1000 字节的数据包。

因此，接收端返回的数据包的 ACK 依然是 1001。这表示：“喂，发数据的，别往后发了，你第 1001 字节开始的数据还没来呢”。可以想见，发送端以后每次发送数据包得到的确认中，ACK 的值都是 1001。当连续收到三次确认之后，发送方会意识到：“对方还没有接收到数据，这个包需要重传”。

因此，引入窗口的概念后，被发送的数据不能立刻丢弃，需要缓存起来以备将来需要重发。

利用窗口发送数据的过程可以用下图表示：

![](http://upload-images.jianshu.io/upload_images/1171077-59062a2b47a71189.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

如果是数据包没有丢失，但是确认包丢失了呢？这就是窗口最擅长处理的问题了。假设发送发收到的确认包中的 ACK 第一次是 1001，第二次是 4001。那么我们完全可以相信中间的两个包是成功被接收的。因为如果有没接收到的包，接收方是不会增加 ACK 的。

在这种情况下，如果不使用窗口，发送方就需要重传第二、三个数据包，但是有了窗口的概念后，发送方就省略了两次重传。因此使用窗口实际上可以理解为“空间换时间”。

![](http://upload-images.jianshu.io/upload_images/1171077-3bb9a03c1b712fa0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

###流量控制
###窗口大小
如果窗口过大，会导致接收方的缓存区数据溢出。这时候本该被接收的数据反而丢弃了，就会导致无意义的重传。因此，窗口大小是一个可以改变的值，它由接收端主机控制，附加在 TCP 首部的“窗口大小”字段中。

###慢启动
在连接建立的初期，如果窗口比较大，发送方可能会突然发送大量数据，导致网络瘫痪。因此，在通信一开始时，TCP 会通过慢启动算法得出窗口的大小，对发送数据量进行控制。

流量控制是由发送方和接收方共同控制的。刚刚我们介绍了接收方会把自己能够承受的最大窗口长度写在 TCP 首部中，实际上在发送方这里，也存在流量控制，它叫拥塞窗口。TCP 协议中的窗口是指发送方窗口和接收方窗口的较小值。

慢启动过程如下：

1. 通信开始时，发送方的拥塞窗口大小为 1。每收到一个 ACK 确认后，拥塞窗口翻倍。
2. 由于指数级增长非常快，很快地，就会出现确认包超时。
3. 此时设置一个“慢启动阈值”，它的值是当前拥塞窗口大小的一半。
4. 同时将拥塞窗口大小设置为 1，重新进入慢启动过程。
5. 由于现在“慢启动阈值”已经存在，当拥塞窗口大小达到阈值时，不再翻倍，而是线性增加。
6. 随着窗口大小不断增加，可能收到三次重复确认应答，进入“快速重发”阶段。
7. 这时候，TCP 将“慢启动阈值”设置为当前拥塞窗口大小的一半，再将拥塞窗口大小设置成阈值大小（也有说加 3）。
8. 拥塞窗口又会线性增加，直至下一次出现三次重复确认应答或超时。

以上过程可以用下图概括：
![](http://upload-images.jianshu.io/upload_images/1171077-bff9c2754298154f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)	

##（六）HTTP 与 HTTPS 简介
本文是准备面试过程中网络部分总结整理的最后一篇文章，主要介绍以下知识：

- HTTP 协议概述
- POST 请求和 GET 请求
- Cookie 和 Session
- 数据传输时的加密
- HTTPS 简介

###HTTP协议

在 OSI 七层模型中，HTTP 协议位于最顶层的应用层中。通过浏览器访问网页就直接使用了 HTTP 协议。使用 HTTP 协议时，客户端首先与服务端的 80 端口建立一个 TCP 连接，然后在这个连接的基础上进行请求和应答，以及数据的交换。

![](http://upload-images.jianshu.io/upload_images/1171077-722b8c2d372778f6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)


HTTP 有两个常用版本，分别是 1.0 和 1.1。主要区别在于 HTTP 1.0 中每次请求和应答都会使用一个新的 TCP 连接，而从 HTTP 1.1 开始，运行在一个 TCP 连接上发送多个命令和应答。因此大幅度减少了 TCP 连接的建立和断开，提高了效率。

由 HTTP 协议加载出来的网页，通常使用 HTML 语言来描述，因此 HTML 也可以理解为网页的一种数据格式。HTML 是一段纯文本，可以指定网页中的文字、图像、音频视频图片、链接，以及它们的颜色、位置等。无论计算机的底层结构如何，也无论网络底层使用了哪些协议，使用 HTML 展示出来的效果基本上是一致的。从这个角度来说 HTML 位于 OSI 七层模型的表现层。

###POST 请求和 GET 请求
HTTP 有八种请求（也称方法），其中最常见的是 GET 请求和 POST 请求。

GET 请求通常用于查询、获取数据，而 POST 请求则用于发送数据，除了用途上的区别，它们还有以下这些不同：

1. GET 请求可以被缓存，可以被收藏为书签，但 POST 不行。
2. GET 请求会保留在浏览器的历史记录中，POST 不会。
3. GET 请求的长度有限制（不同的浏览器不一样，大约在几 Kb 左右），URL 的数据类型只能是 ASCII 字符，POST 请求没有限制。
4. GET 请求的参数在 URL 中，因此绝不能用 GET 请求传输敏感数据。POST 请求数据则写在 HTTP 的请求头中，安全性略高于 GET 请求。

**注意：**

POST 请求仅比 GET 请求略安全一点，它的数据不在 URL 中，但依然以明文的形式存放于 HTTP 的请求头中。

###Cookie 和 Session

HTTP 是一种无状态的连接，客户端每次读取 web 页面时，服务器都会认为这是一次新的会话。但有时候我们又需要持久保持某些信息，比如登录时的用户名、密码，用户上一次连接时的信息等。这些信息就由 Cookie 和 Session 保存。

这两者的根本性区别在于，cookie 保存在客户端上，而 session 则保存在服务器中。由此我们还可以拓展出以下结论：

1. cookie 相对来说不安全，浏览器可以分析本地的 cookie 进行 cookie 欺骗。
2. session 可以设置超时时间，超过这个时间后就失效，以免长期占用服务端内存。
3. 单个 cookie 的大小有限制（4 Kb），每个站点的 cookie 数量一般也有限制（20个）。
4. 客户端每次都会把 cookie 发送到服务端，因此服务端可以知道 cookie，但是客户端不知道 session。
5. 当服务器接收到 cookie 后，会根据 cookie 中的 SessionID 来找到这个客户的 session。如果没有，则会生成一个新的 SessionID 发送给客户端。

###加密

加密分为两种，对称加密和非对称加密。在解释这两者的含义前，先来看一下简单的加密、解密过程：

![](http://upload-images.jianshu.io/upload_images/1171077-69c8f5e577b9c623.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

所谓的对称，就是指加密秘钥和解密秘钥相同，而非对称自然就是指两者不同。

举一个对称加密的例子。假设这里的加密算法是加法，解密算法是减法。如果明文数据是 10，秘钥是 1，那么加密数据就是 10 + 1 = 11，如果接收方不知道秘钥，就不知道密文 11 应该减去几。反之，如果接收方知道秘钥是 1，就可以通过 11 - 1 = 10 计算出明文数据。

常见的一个非对称加密算法是 RSA 算法，它主要利用了“两个素数求乘积容易，但是将乘积分解为两个素数很难”这一思想。它的具体原理不在本文讨论范围，有兴趣的读者可以查看文章末尾的参考文章。

在非对称加密中，利用公钥加密的数据能且只能通过私钥解密，通过私钥加密的数据能且只能通过公钥解密。

对称加密的优点在于速度快，但是假设秘钥由服务器保存，如何安全的让客户端得到秘钥是需要解决的问题。因此实际的网络传输中，通常使用对称加密与非对称加密结合的方式，服务端通过非对称加密将对称秘钥发给客户端。此后双方使用这个对称密钥进行通信。

###HTTPS

我们知道 HTTP 协议直接使用了 TCP 协议进行数据传输。由于数据没有加密，都是直接明文传输，所以存在以下三个风险：

窃听风险：第三方节点可以获知通信内容。
篡改风险：第三方节点可以修改通信内容。
冒充风险：第三方节点可以冒充他人身份参与通信。
比如你在手机上打开应用内的网页时，有时会看到网页底部弹出了广告，这实际上就说明你的 HTTP 内容被窃听、并篡改了。

HTTPS 协议旨在解决以上三个风险，因此它可以：

1. 保证所有信息加密传输，无法被第三方窃取。
2. 为信息添加校验机制，如果被第三方恶意破坏，可以检测出来。
3. 配备身份证书，防止第三方伪装参与通信。
HTTPS 的结构如图所示：

![](http://upload-images.jianshu.io/upload_images/1171077-586c5296c31b4ab8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

可见它仅仅是在 HTTP 和 TCP 之间新增了一个 TLS/SSL 加密层，这也印证了一句名言：“一切计算机问题都可以通过添加中间层解决”。

使用 HTTPS 时，服务端会将自己的证书发送给客户端，其中包含了服务端的公钥。基于非对称加密的传输过程如下：

1. 客户端使用公钥将信息加密，密文发送给服务端
2. 服务端用自己的私钥解密，再将返回数据用私钥加密发回客户端
4. 客户端用公钥解密
5. 这里的证书是服务器证明自己身份的工具，它由权威的证书颁发机构（CA）发给申请者。如果证书是虚假的，或者是自己给自己颁发的证书，服务器就会不认可这个证书并发出警告：

![](http://upload-images.jianshu.io/upload_images/1171077-e148ee4d305f4a46.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

**总结一下 HTTPS 协议是如何避免前文所说的三大风险的：**

1. 先用非对称加密传输密码，然后用这个密码对称加密数据，使得第三方无法获得通信内容
2. 发送方将数据的哈希结果写到数据中，接收方解密后对比数据的哈希结果，如果不一致则说明被修改。由于传输数据加密，第三方无法修改哈希结果。
3. 由权威机构颁发证书，再加上证书校验机制，避免第三方伪装参与通信。

